import numpy as np
import sympy
from sympy import pi
from sympy.parsing.mathematica import parse_mathematica

from typing import Callable, Tuple

from CommonUtils import replaceGreekSymbols, dictToOrderedList


class ParsedExpression:
    """ Class ParsedExpression
    """

    ## Original expression in string form
    stringExpression: str = ""
    ## Symbolic expression generated by sympy
    sympyExpression: sympy.Expr = None
    ## Parsed expression turned to a evaluatable lambda function
    lambdaExpression: Callable = None

    ## sympy symbols that our expression depends on 
    symbols: list[sympy.Symbol] = []


    """List of arguments needed to evaluate self.lambdaExpression, in correct order.
    This needs to be specified from outside. Names should match sympy symbol names. 
    """ 
    functionArguments: list[str] = []

    def __init__(self, expression: str = None, bReplaceGreekSymbols=True):
        if (expression != None):
            self.parseNewExpression(expression, bReplaceGreekSymbols)
            

    def parseNewExpression(self, expression: str, bReplaceGreekSymbols=True) -> None:
        """ This parses a string and turns it into sympy expression, stored internally.
        bReplaceGreekSymbols specifies whether Greek letters from Mathematica should be replaced with ANSI text;
        see CommonUtils.replaceGreekSymbols() for conversion rules.
        """
        if (not isinstance(expression, str)):
            raise RuntimeWarning(f"Warning from {self.__class__.__name__}: Can't parse expression of type {type(expression)}")  
        else:

            if (bReplaceGreekSymbols):
                expression = replaceGreekSymbols(expression) 

            self.stringExpression = expression
            self.sympyExpression, self.symbols = self._parseMathematicaExpression(expression)


    def makeCallable(self, functionArguments: list[str]) -> None:
        """Turn our sympyExpression into a optimized function that takes in functionArguments (ordering is important).
        After this the expression can be evaluated through the __call__ method by passing the arguments as a list. 
        Argument names should match symbols names that appear in self.symbols. 
        In principle you can include parameters that the function actually doesn't depend on:
        this can be useful for eg. collections of complicated expressions 
        """

        ## TODO should have some sanity checks here to ensure symbols match the given argument list

        ## Convert to evaluatable function of form f(functionArguments)
        self.lambdaExpression = self.exprToFunction(self.sympyExpression, functionArguments)
        self.functionArguments = functionArguments


    def __call__(self, functionArguments: list[float]) -> float:
        """This evaluates self.lambdaExpression with specified arguments.
        Argument should be a list of numbers, in the order that matches 
        the list originally given to makeCallable().
        """

        ## Unpack the list to make it work with our lambda
        return self.lambdaExpression(*functionArguments)
    

    ## TODO some redundancy since a similar function is also defined in ParameterMatching, so cleanup
    def _paramDictToOrderedList(self, paramDict: dict[str, float]) -> list[float]:
        """Put input dict to correct order for our lambda function. 
        """
        outList = [None] * len(self.functionArguments)
        
        ## Fill the list in correct order, if a key is not found we put the corresponding element to None
        for i in range(len(outList)):
            if (self.functionArguments[i] in paramDict):
                outList[i] = paramDict[ self.functionArguments[i] ]
            else:
                outList[i] = None

        return outList


    @staticmethod
    def _parseMathematicaExpression(expression: str, bSubstituteConstants: bool = True) -> Tuple[sympy.Expr, list[sympy.Symbol]]:
        """ Parses a string exported from Mathematica.
        bSubstituteConstants specifies if we replace numerical constants like Glaisher with their numerical values
        -----------
        Returns a tuple of sympy objects:
        expression, symbols.
        """

        sympyExpr: sympy.Expr 
        sympyExpr = parse_mathematica(expression)
        
        if (bSubstituteConstants):
            ## Do this here to prevent things like Glaisher from appearing in list of free symbols
            sympyExpr = ParsedExpression._substNumericalConstants(sympyExpr)

        ## find symbols in the expression
        symbols = sympyExpr.free_symbols

        return sympyExpr, symbols


    @staticmethod
    def exprToFunction(sympyExpression: sympy.Expr, argumentList: list[str]) -> Callable:
        """argumentList specifies names and order for arguments of the returned function.
        The names should match symbols names that appear in sympyExpression. 
        In principle you can include parameters that the function actually doesn't depend on:
        this can be useful for eg. collections of complicated expressions 
        """

        argumentSymbols = []
        for s in argumentList:
            argumentSymbols.append(sympy.Symbol(s))

        return sympy.lambdify(argumentSymbols, sympyExpression, modules='numpy')
    
    
    @staticmethod
    def _substNumericalConstants(sympyExpression: sympy.Expr) -> sympy.Expr:
        """Replaces symbols corresponding to mathematical constants 
        with their numerical values. You have to manually define the relevant constants here.
        Does not modify the original expression in-place.
        """

        newExpr = sympyExpression

        newExpr = newExpr.subs('Glaisher', 1.28242712910062)

        return newExpr
    


""" class ParsedExpressionSystem -- Describes a collection of ParsedExpressions that are to be evaluated simultaneously with same input.
"""
class ParsedExpressionSystem:

    parsedExpressions: list[ParsedExpression]
    """Arguments needed to evaluate our lambda equations, in correct order."""
    functionArguments: list[str]

    def __init__(self, fileName: str = None):
        if (fileName):
            self.parseExpressions(fileName)

        ## TODO should maybe check that all expressions use the same input ordering. Currently this is automatic, 
        ## but things will go horribly wrong if the order ever changes by some reason


    def parseExpressions(self, fileName: str) -> Tuple:
        """Read system of expressions from file, one per line.
        The expressions will become functions of all symbols that appear. 
        """
        with open(fileName, "r") as file:
            expressions = file.readlines()
        
        parsedSymbols = []
        self.parsedExpressions = []
        for line in expressions:
            try:
                expr = ParsedExpression(line, bReplaceGreekSymbols=True)

                self.parsedExpressions.append(expr)

                ## find symbols but store as string, not the sympy type  
                for symbol in expr.symbols:
                    ## NOTE this conversion will cause issues with pathological symbols like "A B" 
                    # https://stackoverflow.com/questions/59401738/convert-sympy-symbol-to-string-such-that-it-can-always-be-parsed
                    symbol_str = str(symbol)
                    if symbol_str not in parsedSymbols:
                        parsedSymbols.append(symbol_str)
                        
            except ValueError:
                print(f"Error parsing file {fileName}, line: {line}")

        self._lambdifyExpressions(parsedSymbols)


    def evaluateSystemWithDict(self, inputDict: dict[str, float]) -> list[float]:
        """
        """
        ## Collect inputs from the dict and put them in correct order. I do this by taking the right order from our first expression.
        ## This is fine since all our expressions use the same input list. 
        inputList = self.parsedExpressions[0]._paramDictToOrderedList(inputDict)

        outList = [None] * len(self.parsedExpressions)
        for i in len(outList):
            outList[i] = self.parsedExpressions[i](inputList)
        

    def evaluateSystem(self, arguments: list[float]) -> Tuple:
        """Evaluates the system of expressions at given input and returns a tuple of floats.
        """
        return tuple( [expr(arguments) for expr in self.parsedExpressions] )


    def __call__(self, arguments: list[float]) -> Tuple:
        """Just calls evaluateSystem()"""
        return self.evaluateSystem(arguments)



    def _lambdifyExpressions(self, arguments: list[str]) -> None:
        """
        """
        self.functionArguments = arguments
        for expr in self.parsedExpressions:
            expr.makeCallable(arguments)



"""Class SystemOfEquations -- System of parsed expression that we interpret as a set of equation. 
Each expression is interpreted as an equation of form ``expr == 0``. We also distinguish between symbols 
that describe the unknowns versus symbols that are known inputs to the expressions.
"""
class SystemOfEquations(ParsedExpressionSystem):

    ## what we solve for
    unknownVariables: list[str]
    ## "known" inputs
    otherVariables: list[str]

    def __init__(self, fileName: str, unknownVariables: list[str]):
        
        ## Call parent constructor
        super().__init__(fileName)

        self.unknownVariables = unknownVariables

        ## Check that we have same number of eqs as unknowns 
        assert len(unknownVariables) == len(self.parsedExpressions)

               
        ## Check that the eqs actually contain our unknowns
        for s in unknownVariables:
            assert s in self.functionArguments

        self._rearrangeSymbols()

    def getOtherVariablesFromDict(self, otherVariablesDict: dict[str, float]) -> list[float]:
        """Puts numbers from dict in correct order for our lambda evaluation, does not look for our unknown variables.
        """
        return dictToOrderedList(otherVariablesDict, self.otherVariables)


    def _rearrangeSymbols(self) -> None:
        """This rearranges our internal symbol list and expression lambdas so that the unknown variables come before other variables.
        For internal use only.
        """
        ## First create a filtered list that contains all non-unknowns. With a crazy oneliner of course
        filteredArguments = [ item for item in self.functionArguments if item not in self.unknownVariables ]
        rearrangedArguments = self.unknownVariables + filteredArguments

        self.otherVariables = filteredArguments

        ## And create new lambdas
        self._lambdifyExpressions(rearrangedArguments)


    def getEquations(self) -> list[Callable]:
        """Returns a list of our lambdas.
        """
        eqs = [None] * len(self.parsedExpressions)
        for i in range(len(eqs)):
            eqs[i] = self.parsedExpressions[i].lambdaExpression

        return eqs
