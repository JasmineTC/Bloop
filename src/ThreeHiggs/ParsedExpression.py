import numpy as np
import sympy
from sympy import pi
from sympy.parsing.mathematica import parse_mathematica

from typing import Callable, Tuple

from CommonUtils import replaceGreekSymbols


class ParsedExpression:
    """ Class ParsedExpression
    """

    ## Original expression in string form
    stringExpression: str = ""
    ## Symbolic expression generated by sympy
    sympyExpression: sympy.Expr = None
    ## Parsed expression turned to a evaluatable lambda function
    lambdaExpression: Callable = None

    ## sympy symbols that our expression depends on 
    symbols: list[sympy.Symbol] = []


    """List of arguments needed to evaluate self.lambdaExpression, in correct order.
    This needs to be specified from outside. Names should match sympy symbol names. 
    """ 
    functionArguments: list[str] = []

    def __init__(self, expression: str = None, bReplaceGreekSymbols=True):
        if (expression != None):
            self.parseNewExpression(expression, bReplaceGreekSymbols)
            

    def parseNewExpression(self, expression: str, bReplaceGreekSymbols=True) -> None:
        """ This parses a string and turns it into sympy expression, stored internally.
        bReplaceGreekSymbols specifies whether Greek letters from Mathematica should be replaced with ANSI text;
        see CommonUtils.replaceGreekSymbols() for conversion rules.
        """
        if (not isinstance(expression, str)):
            raise RuntimeWarning(f"Warning from {self.__class__.__name__}: Can't parse expression of type {type(expression)}")  
        else:

            if (bReplaceGreekSymbols):
                expression = replaceGreekSymbols(expression) 

            self.stringExpression = expression
            self.sympyExpression, self.symbols = self._parseMathematicaExpression(expression)


    def makeCallable(self, functionArguments: list[str]) -> None:
        """Turn our sympyExpression into a optimized function that takes in functionArguments (ordering is important).
        After this the expression can be evaluated through the __call__ method by passing the arguments as a list. 
        Argument names should match symbols names that appear in self.symbols. 
        In principle you can include parameters that the function actually doesn't depend on:
        this can be useful for eg. collections of complicated expressions 
        """

        ## TODO should have some sanity checks here to ensure symbols match the given argument list

        ## Convert to evaluatable function of form f(functionArguments)
        self.lambdaExpression = self.exprToFunction(self.sympyExpression, functionArguments)
        self.functionArguments = functionArguments


    def __call__(self, functionArguments: list[float]) -> float:
        """This evaluates self.lambdaExpression with specified arguments.
        Argument should be a list of numbers, in the order that matches 
        the list originally given to makeCallable().
        """

        ## Unpack the list to make it work with our lambda
        return self.lambdaExpression(*functionArguments)
    

    ## TODO some redundancy since a similar function is also defined in ParameterMatching, so cleanup
    def _paramDictToOrderedList(self, paramDict: dict[str, float]) -> list[float]:
        """Put input dict to correct order for our lambda function. 
        """
        outList = [None] * len(self.functionArguments)
        
        ## Fill the list in correct order, if a key is not found we put the corresponding element to None
        for i in range(len(outList)):
            if (self.functionArguments[i] in paramDict):
                outList[i] = paramDict[ self.functionArguments[i] ]
            else:
                outList[i] = None

        return outList


    @staticmethod
    def _parseMathematicaExpression(expression: str, bSubstituteConstants: bool = True) -> Tuple[sympy.Expr, list[sympy.Symbol]]:
        """ Parses a string exported from Mathematica.
        bSubstituteConstants specifies if we replace numerical constants like Glaisher with their numerical values
        -----------
        Returns a tuple of sympy objects:
        expression, symbols.
        """

        sympyExpr: sympy.Expr 
        sympyExpr = parse_mathematica(expression)
        
        if (bSubstituteConstants):
            ## Do this here to prevent things like Glaisher from appearing in list of free symbols
            sympyExpr = ParsedExpression._substNumericalConstants(sympyExpr)

        ## find symbols in the expression
        symbols = sympyExpr.free_symbols

        return sympyExpr, symbols


    @staticmethod
    def exprToFunction(sympyExpression: sympy.Expr, argumentList: list[str]) -> Callable:
        """argumentList specifies names and order for arguments of the returned function.
        The names should match symbols names that appear in sympyExpression. 
        In principle you can include parameters that the function actually doesn't depend on:
        this can be useful for eg. collections of complicated expressions 
        """

        argumentSymbols = []
        for s in argumentList:
            argumentSymbols.append(sympy.Symbol(s))

        return sympy.lambdify(argumentSymbols, sympyExpression, modules='numpy')
    
    
    @staticmethod
    def _substNumericalConstants(sympyExpression: sympy.Expr) -> sympy.Expr:
        """Replaces symbols corresponding to mathematical constants 
        with their numerical values. You have to manually define the relevant constants here.
        Does not modify the original expression in-place.
        """

        newExpr = sympyExpression

        newExpr = newExpr.subs('Glaisher', 1.28242712910062)

        return newExpr
    


""" class SystemOfParsedEquations -- Describes system of eqs [eq1, eq2, ...] which we interpret as eq1 == 0, eq2 == 0, etc"""
class ParsedSystemOfEquations:

    parsedEquations: list[ParsedExpression]
    """Arguments needed to evaluate our lambda equations, in correct order."""
    functionArguments: list[str]

    def __init__(self, fileName: str = None):
        if (fileName):
            self.parseEquations(fileName)



    def parseEquations(self, fileName: str) -> Tuple:
        """Read system of expressions from file, one per line. We interpret these as LHS == 0 where LHS are the read expressions.
        The LHS will become functions of all symbols that appear 
        """
        with open(fileName, "r") as file:
            expressions = file.readlines()
        
        parsedSymbols = []
        parsedExpressions: list[ParsedExpression] = []
        for line in expressions:
            try:
                expr = ParsedExpression(line, bReplaceGreekSymbols=True)

                parsedExpressions.append(expr)

                ## find symbols but store as string, not the sympy type  
                for symbol in expr.symbols:
                    ## NOTE this conversion will cause issues with pathological symbols like "A B" 
                    # https://stackoverflow.com/questions/59401738/convert-sympy-symbol-to-string-such-that-it-can-always-be-parsed
                    symbol_str = str(symbol)
                    if symbol_str not in parsedSymbols:
                        parsedSymbols.append(symbol_str)
                        

            except ValueError:
                print(f"Error parsing file {fileName}, line: {line}")

        self.functionArguments = parsedSymbols
        for expr in parsedExpressions:
            expr.makeCallable(parsedSymbols)
        
