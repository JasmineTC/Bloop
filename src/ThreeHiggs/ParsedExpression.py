import numpy as np
import sympy
from sympy import pi
from sympy.parsing.mathematica import parse_mathematica

from typing import Callable, Tuple

from CommonUtils import replaceGreekSymbols


class ParsedExpression:
    """ Class ParsedExpression
    """

    ## Original expression in string form
    stringExpression: str = ""
    ## Symbolic expression generated by sympy
    sympyExpression: sympy.Expr = None
    ## Parsed expression turned to a evaluatable lambda function
    lambdaExpression: Callable = None

    ## sympy symbols that our expression depends on 
    symbols: list[sympy.Symbol] = []

    """List of arguments needed to evaluate self.lambdaExpression, in correct order.
    This is user-specified. Names should match sympy symbol names. 
    """ 
    functionArguments: list[str] = []

    def __init__(self, expression: str = None, bReplaceGreekSymbols=True):
        if (expression != None):
            self.parseNewExpression(expression, bReplaceGreekSymbols)
            

    def parseNewExpression(self, expression: str, bReplaceGreekSymbols=True) -> None:
        """ This parses a string and turns it into sympy expression, stored internally.
        bReplaceGreekSymbols specifies whether Greek letters from Mathematica should be replaced with ANSI text;
        see CommonUtils.replaceGreekSymbols() for conversion rules.
        """
        if (not isinstance(expression, str)):
            raise RuntimeWarning(f"Warning from {self.__class__.__name__}: Can't parse expression of type {type(expression)}")  
        else:

            if (bReplaceGreekSymbols):
                expression = replaceGreekSymbols(expression) 

            self.stringExpression = expression
            self.sympyExpression, self.symbols = self._parseMathematicaExpression(expression)


    def makeCallable(self, functionArguments: list[str]) -> None:
        """Turn our sympyExpression into a optimized function that takes in functionArguments (ordering is important).
        After this the expression can be evaluated through the __call__ method by passing the arguments as a list. 
        Argument names should match symbols names that appear in self.symbols. 
        In principle you can include parameters that the function actually doesn't depend on:
        this can be useful for eg. collections of complicated expressions 
        """

        ## TODO should have some sanity checks here to ensure symbol match the given argument list

        ## Convert to evaluatable function of form f(functionArguments)
        self.lambdaExpression = self.exprToFunction(self.sympyExpression, functionArguments)
        self.functionArguments = functionArguments


    def __call__(self, functionArguments: list[float]) -> float:
        """This evaluates self.lambdaExpression with specified arguments.
        Argument should be a list of numbers, in the order that matches 
        the list originally given to makeCallable().
        """

        ## Unpack the list to make it work with our lambda
        return self.lambdaExpression(*functionArguments)


    @staticmethod
    def _parseMathematicaExpression(expression: str) -> Tuple[sympy.Expr, list[sympy.Symbol]]:
        """ Parses a string exported from Mathematica.
        -----------
        Returns a tuple of sympy objects:
        expression, symbols.
        """

        sympyExpr = parse_mathematica(expression)

        ## find symbols in the expression
        symbols = sympyExpr.free_symbols

        return sympyExpr, symbols


    @staticmethod
    def exprToFunction(sympyExpression: sympy.Expr, argumentList: list[str]) -> Callable:
        """argumentList specifies names and order for arguments of the returned function.
        The names should match symbols names that appear in sympyExpression. 
        In principle you can include parameters that the function actually doesn't depend on:
        this can be useful for eg. collections of complicated expressions 
        """

        argumentSymbols = []
        for s in argumentList:
            argumentSymbols.append(sympy.Symbol(s))

        return sympy.lambdify(argumentSymbols, sympyExpression, modules='numpy')