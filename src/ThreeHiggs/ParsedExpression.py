import numpy as np
import sympy
from sympy.parsing.mathematica import parse_mathematica

from typing import Callable, Tuple

from .CommonUtils import replaceGreekSymbols

pi = float(sympy.pi.evalf())
EulerGamma = float(sympy.EulerGamma.evalf())
Glaisher = 1.28242712910062
def log(x):
    return float(sympy.log(float(x)))

def sqrt(x):
    return float(sympy.sqrt(float(x)))

class ParsedExpression:
    """ Class ParsedExpression
    """

    """ ``Name`` of the expression. Can be interpreted as name of function that evaluates the expr.
    This is set when parsing: For subst rules like "A -> expr" we treat A as the identifier 
    and expr as the expression to be evaluated.
    For non-subst rules the identifier is "Unknown".
    """
    identifier: str = "Unknown"
    ## Original expression in string form
    stringExpression: str = ""
    ## Symbolic expression generated by sympy
    sympyExpression: sympy.Expr = None
    ## Parsed expression turned to a evaluatable lambda function
    lambdaExpression: Callable = None

    ## sympy symbols that our expression depends on 
    symbols: list[sympy.Symbol] = []

    """List of arguments needed to evaluate self.lambdaExpression, in correct order.
    This needs to be specified from outside. Names should match sympy symbol names. 
    """ 
    functionArguments: list[str] = []

    def __init__(self, expression: str = None, bReplaceGreekSymbols=True):
        if (expression != None):
            self.parseNewExpression(expression, bReplaceGreekSymbols)
            

    def parseNewExpression(self, expression: str, bReplaceGreekSymbols=True) -> None:
        """ This parses a string and turns it into sympy expression, stored internally.
        bReplaceGreekSymbols specifies whether Greek letters from Mathematica should be replaced with ANSI text;
        see CommonUtils.replaceGreekSymbols() for conversion rules.
        """

        if (not isinstance(expression, str)):
            raise RuntimeWarning(f"Warning from {self.__class__.__name__}: Can't parse expression of type {type(expression)}")  
        else:

            ## these wont work currently:
            if ('=' in expression) or ('==' in expression):
                raise RuntimeError(f"Don't how know to interpret parsed expression {expression}!")

            if (bReplaceGreekSymbols):
                expression = replaceGreekSymbols(expression) 
            
            self.stringExpression = expression

            ## If the expression is a Mathematica substitution rule, we parse just the RHS and use LHS as the identifier
            if ("->" in expression):
                lhs, rhs = map(str.strip, expression.split("->"))

                expression = rhs
                self.identifier = lhs

            self.stringExpression = expression

            if not self.stringExpression:
                from pdb import set_trace
                set_trace()

            self.sympyExpression, self.symbols = self._parseMathematicaExpression(expression)


    def makeCallable(self, functionArguments: list[str]) -> None:
        """Turn our sympyExpression into a optimized function that takes in functionArguments (ordering is important).
        After this the expression can be evaluated through the __call__ method by passing the arguments as a list. 
        Argument names should match symbols names that appear in self.symbols. 
        In principle you can include parameters that the function actually doesn't depend on:
        this can be useful for eg. collections of complicated expressions 
        """

        ## TODO should have some sanity checks here to ensure symbols match the given argument list

        ## TODO assert that the expression contains no things like "==" "=" "->" etc

        ## Convert to evaluatable function of form f(functionArguments)
        self.lambdaExpression = self.exprToFunction(self.sympyExpression, functionArguments)
        self.functionArguments = functionArguments


    def __call__(self, functionArguments: list[float]) -> float:
        """This evaluates self.lambdaExpression with specified arguments.
        Argument should be a list of numbers, in the order that matches 
        the list originally given to makeCallable().
        """

        ## Unpack the list to make it work with our lambda
        
        try:
            return eval(self.lambdaExpression, 
                        functionArguments | {"log": log, 
                                             "sqrt": sqrt, 
                                             "pi": pi, 
                                             "EulerGamma": EulerGamma,
                                             "Glaisher": Glaisher})

        except TypeError as err:
            print(err)
            from pdb import set_trace
            set_trace()

    def __str__(self) -> str:
        return self.identifier + " == " + self.stringExpression

    @staticmethod
    def _parseMathematicaExpression(expression: str, bSubstituteConstants: bool = True) -> Tuple[sympy.Expr, list[sympy.Symbol]]:
        """ Parses a string exported from Mathematica.
        bSubstituteConstants specifies if we replace numerical constants like Glaisher with their numerical values
        -----------
        Returns a tuple of sympy objects:
        expression, symbols.
        """

        sympyExpr = parse_mathematica(expression)
        
        if (bSubstituteConstants):
            ## Do this here to prevent things like Glaisher from appearing in list of free symbols
            sympyExpr = ParsedExpression._substNumericalConstants(sympyExpr)

        ## find symbols in the expression
        symbols = sympyExpr.free_symbols

        return sympyExpr, symbols


    @staticmethod
    def exprToFunction(sympyExpression: sympy.Expr, argumentList: list[str]) -> Callable:
        """argumentList specifies names and order for arguments of the returned function.
        The names should match symbols names that appear in sympyExpression. 
        In principle you can include parameters that the function actually doesn't depend on:
        this can be useful for eg. collections of complicated expressions 
        """

        argumentSymbols = []
        for s in argumentList:
            argumentSymbols.append(sympy.Symbol(s))

        from random import random
        return compile(str(sympyExpression), "<string>", mode = "eval")
    
    @staticmethod
    def _substNumericalConstants(sympyExpression: sympy.Expr) -> sympy.Expr:
        """Replaces symbols corresponding to mathematical constants 
        with their numerical values. You have to manually define the relevant constants here.
        Does not modify the original expression in-place.
        """

        newExpr = sympyExpression

        newExpr = newExpr.subs('Glaisher', 1.28242712910062)

        return newExpr
    


""" class ParsedExpressionSystem -- Describes a collection of ParsedExpressions that are to be evaluated simultaneously with same input.
"""
class ParsedExpressionSystem:

    parsedExpressions: list[ParsedExpression]
    """Arguments needed to evaluate our lambda functions, in correct order."""
    functionArguments: list[str]

    def __init__(self, fileName: str = None):
        if (fileName):
            self.parseExpressions(fileName)

    def parseExpressions(self, fileName: str) -> Tuple:
        """Read system of expressions from file, one per line.
        The expressions will become functions of all symbols that appear. 
        """

        parsedSymbols = []
        self.parsedExpressions = []
        
        with open(fileName, "r", encoding="utf-8") as file:
            for line in file.readlines():
                try:
    
                    expr = ParsedExpression(line, bReplaceGreekSymbols=True)
    
                    self.parsedExpressions.append(expr)
    
                    ## find symbols but store as string, not the sympy type  
                    for symbol in expr.symbols:
                        ## NOTE this conversion will cause issues with pathological symbols like "A B" 
                        # https://stackoverflow.com/questions/59401738/convert-sympy-symbol-to-string-such-that-it-can-always-be-parsed
                        symbol_str = str(symbol)
                        if symbol_str not in parsedSymbols:
                            parsedSymbols.append(symbol_str)
                            
                except ValueError:
                    print(f"Error parsing file {fileName}, line: {line}")
    
            self._lambdifyExpressions(parsedSymbols)


    def evaluateSystemWithDict(self, inputDict: dict[str, float], bReturnDict=False) -> list[float]:
        """Optional argument is a hack
        """
        ## Collect inputs from the dict and put them in correct order. I do this by taking the right order from our first expression.
        ## This is fine since all our expressions use the same input list. 
        outList = [None] * len(self.parsedExpressions)
        for i in np.arange(len(outList)):
            outList[i] = self.parsedExpressions[i](inputDict)

        if not bReturnDict:
            return outList
        else:
            return  { self.parsedExpressions[i].identifier : outList[i] for i in np.arange(len(outList)) } 

    def __call__(self, arguments: list[float]) -> Tuple:
        """Just calls evaluateSystem()"""
        return self.evaluateSystemWithDict(arguments)

    def __str__(self) -> str:
        return str([ str(expr) for expr in self.parsedExpressions ])

    def getExpressionNames(self) -> list[str]:
        return [ expr.identifier for expr in self.parsedExpressions ]


    def _lambdifyExpressions(self, arguments: list[str]) -> None:
        """
        """
        self.functionArguments = arguments
        for expr in self.parsedExpressions:
            expr.makeCallable(arguments)


"""Class SystemOfEquations -- System of parsed expression that we interpret as a set of equation. 
Each expression is interpreted as an equation of form ``expr == 0``. We also distinguish between symbols 
that describe the unknowns versus symbols that are known inputs to the expressions.
"""
class SystemOfEquations(ParsedExpressionSystem):

    def __init__(self, fileName: str, unknownVariables: list[str]):
        
        super().__init__(fileName)

        ## what we solve for
        self.unknownVariables = unknownVariables

        ## Check that we have same number of eqs as unknowns 
        assert len(unknownVariables) == len(self.parsedExpressions)

        ## Check that the eqs actually contain our unknowns
        for s in unknownVariables:
            if not s in self.functionArguments:
                errorString = (f"Error parsing equations from file {fileName}! The expressions don't seem to depend on variable {s}, "
                    f"which was listed in our unknownParameters: {unknownVariables}.")
                raise RuntimeError(errorString)
            

        self._rearrangeSymbols()

    def _rearrangeSymbols(self) -> None:
        """This rearranges our internal symbol list and expression lambdas so that the unknown variables come before other variables.
        For internal use only.
        """
        ## First create a filtered list that contains all non-unknowns. With a crazy oneliner of course
        filteredArguments = [ item for item in self.functionArguments if item not in self.unknownVariables ]
        rearrangedArguments = self.unknownVariables + filteredArguments

        ## "known" inputs
        self.otherVariables = filteredArguments

        ## And create new lambdas
        self._lambdifyExpressions(rearrangedArguments)


    def getEquations(self) -> list[Callable]:
        """Returns a list of our lambdas.
        """
        eqs = [None] * len(self.parsedExpressions)
        for i in range(len(eqs)):
            eqs[i] = self.parsedExpressions[i].lambdaExpression

        return eqs
        
