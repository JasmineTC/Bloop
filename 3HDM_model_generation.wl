(* ::Package:: *)

(** This file defines a 3HDM and computes Veff with 3 background fields. We use permute the fields to bring the mass matrix
into a block diagonal form consisting of two 6x6 matrices. **)


SetDirectory[NotebookDirectory[]];
$LoadGroupMath=True;
(* This is pointing to my DRalgo repo for easier updating *)
(*pathToDRalgo = "/home/lani/repos/DRalgo/DRalgo.m"*)
pathToDRalgo = "/home/jasmine/.Mathematica/Applications/DRalgo/DRalgo.m"
Get[pathToDRalgo]


(* ::Section:: *)
(*Helper functions*)


(** Export expression or list of expressions to file using UTF-8 (important for compatibility) **)
ExportUTF8[fileName_, expr_] := Export[fileName, expr, CharacterEncoding -> "UTF-8"\[NonBreakingSpace]];


(* This is code generated by claude ai, V3.5, I do not pretend to understand it, but it seems to work (with some help with recursion).
Please double check it gives sensible answers!!!*) 
(* Function to remove numerical coefficients and split a single expression into its components *)
splitExpr[expr_] := Module[{terms},
  (* Convert expression to a list of terms split by Plus *)
  terms = List @@ If[Head[expr] === Plus, expr, {expr}];
  
  (* Handle negative terms and extract symbols *)
  DeleteDuplicates @ Flatten[
    terms //. {
      (* Handle division by sqrt and complex combinations *)
      Times[x_Symbol, rest___] :> x,
      (* Handle fractions *)
      x_ /; Head[x] === Times :> List @@ Cases[x, _Symbol],
      (* Handle division *)
      x_ /; Head[x] === Power :> Which[
        MatchQ[x, Power[_, Rational[1, 2]]], First[x],  (* Handle sqrt *)
        MatchQ[x, Power[_, Rational[-1, 2]]], First[x], (* Handle 1/sqrt *)
        True, First[x]
      ],
      (* Ignore pure numbers, I, and sqrt of numbers *)
      _?NumberQ | I | Sqrt[_?NumberQ] -> Sequence[]
    }
  ]
];
symbolsToStrings[symbols_List] := ToString /@ symbols


(*Claude 3.5*)
(* Helper function to remove any suffix from a symbol *)
RemoveSymbolSuffix[expr_Symbol, suffix_String] := 
  If[StringEndsQ[ToString[expr], suffix],
     Symbol[StringReplace[ToString[expr], suffix -> ""]],
     expr]

(* Main function to recursively process expressions *)
RemoveExpressionSuffix[expr_, suffix_String] := 
  expr /. s_Symbol :> RemoveSymbolSuffix[s, suffix]

(* Process entire rule list for a single suffix *)
RemoveSingleSuffix[rules_List, suffix_String] := 
  Map[Rule[
    RemoveSymbolSuffix[#[[1]], suffix], 
    RemoveExpressionSuffix[#[[2]], suffix]
  ] &, rules]

(* Process rules with multiple suffixes *)
RemoveSuffixes[rules_List, suffixes_List] := 
  Fold[RemoveSingleSuffix[#1, #2] &, rules, suffixes]


(*Claude 3.5 *)
(*Function to extract symbols from both sides of substitutions*)
GetSubstitutionSymbols[substitutions_]:=Module[{leftSymbols={},rightSymbols={}},(*Handle single substitution or list of substitutions*)substList=If[Head[substitutions]===List,substitutions,{substitutions}];
(*Helper function to get symbols from an expression*)getSymbols[expr_]:=Union[(*Handle the case where expr is itself a symbol*)If[Head[expr]===Symbol,{expr},{}],(*Handle nested symbols*)Cases[expr,s_Symbol:>s,Infinity]];
(*Process each substitution rule*)Do[(*Extract both sides using pattern matching for Rule*)lhs=sub[[1]];(*First part of the Rule*)rhs=sub[[2]];(*Second part of the Rule*)(*Get all symbols from both sides*)leftSymbols=Union[leftSymbols,getSymbols[lhs]];
rightSymbols=Union[rightSymbols,getSymbols[rhs]];,{sub,substList}];
(*Return both lists*){leftSymbols,rightSymbols}]


(* ::Chapter:: *)
(*3HDM a la Venus*)


(*See 1909.09234 [hep-ph], eq (1) *)


(* ::Subsection:: *)
(*Specify file paths for exporting*)


(** All file paths are relative to the working directory (set above). **)
hardToSoftDirectory = "src/ThreeHiggs/Data/HardToSoft";
softToUltrasoftDirectory = "src/ThreeHiggs/Data/SoftToUltrasoft";
effectivePotentialDirectory = "src/ThreeHiggs/Data/EffectivePotential_threeFields";
variables = "src/ThreeHiggs/Data/Variables";


(* ::Section:: *)
(*Model*)


Group={"SU3","SU2","U1"};
RepAdjoint={{1,1},{2},0};
HiggsDoublet1={{{0,0},{1},1/2},"C"};
HiggsDoublet2={{{0,0},{1},1/2},"C"};
HiggsDoublet3={{{0,0},{1},1/2},"C"};
RepScalar={HiggsDoublet1,HiggsDoublet2,HiggsDoublet3};

ClearAll[g1, g2, g3];
GaugeCouplings={g3,g2,g1};


Rep1={{{1,0},{1},1/6},"L"};
Rep2={{{1,0},{0},2/3},"R"};
Rep3={{{1,0},{0},-1/3},"R"};
Rep4={{{0,0},{1},-1/2},"L"};
Rep5={{{0,0},{0},-1},"R"};
RepFermion1Gen={Rep1,Rep2,Rep3,Rep4,Rep5};
RepFermion3Gen={RepFermion1Gen,RepFermion1Gen,RepFermion1Gen}//Flatten[#,1]&;


(* ::Text:: *)
(*The input for the gauge interactions toDRalgo are then given by*)


{gvvv,gvff,gvss,\[CapitalLambda]1,\[CapitalLambda]3,\[CapitalLambda]4,\[Mu]ij,\[Mu]IJ,\[Mu]IJC,Ysff,YsffC}=AllocateTensors[Group,RepAdjoint,GaugeCouplings,RepFermion3Gen,RepScalar];
(** Note that AllocateTensors[] brings some GroupMath symbols to the global namespace. And these are only removed later when calling ImportModelDRalgo...**)


(* ::Text:: *)
(*The first element is the vector self - interaction matrix :*)


(** Here just list all possible gauge-invariant operators containing 2 doublets **)
(** DRalgo notation is that \[Phi]1\[Phi]2^+ = \!\(
\*SubsuperscriptBox[\(\[Phi]\), \(2\), \(\[Dagger]\)]
\*SubscriptBox[\(\[Phi]\), \(1\)]\ in\ standard\ \(notation . \ \nSo\)\ careful\ here\ to\ make\ sure\ imaginary\ parts\ match\ to\ the\ potential\ in\ our\ draft\) **)
(** I have changed the notation a lot from DRalgo's example 3HDM file. 
My notation for doublet products is \[Phi]ij, where first index is the conjugated doublet **)

InputInv={{1,1},{True,False}}; (*\[Phi]1 \[Phi]1^+*)
\[Phi]11=CreateInvariant[Group,RepScalar,InputInv][[1]]//Simplify//FullSimplify;

InputInv={{2,2},{True,False}}; (*\[Phi]2 \[Phi]2^+*)
\[Phi]22=CreateInvariant[Group,RepScalar,InputInv][[1]]//Simplify//FullSimplify;

InputInv={{3,3},{True,False}}; (*\[Phi]3 \[Phi]3^+*)
\[Phi]33=CreateInvariant[Group,RepScalar,InputInv][[1]]//Simplify//FullSimplify;

InputInv={{1,2},{True,False}}; (*\[Phi]1\[Phi]2^+*)
\[Phi]21=CreateInvariant[Group,RepScalar,InputInv][[1]]//Simplify//FullSimplify;

InputInv={{2,1},{True,False}};(*\[Phi]2\[Phi]1^+*)
\[Phi]12=CreateInvariant[Group,RepScalar,InputInv][[1]]//Simplify//FullSimplify;

InputInv={{1,3},{True,False}}; (*\[Phi]1\[Phi]3^+*)
\[Phi]31=CreateInvariant[Group,RepScalar,InputInv][[1]]//Simplify//FullSimplify;

InputInv={{3,1},{True,False}};(*\[Phi]3\[Phi]1^+*)
\[Phi]13=CreateInvariant[Group,RepScalar,InputInv][[1]]//Simplify//FullSimplify;

InputInv={{2,3},{True,False}}; (*\[Phi]2\[Phi]3^+*)
\[Phi]32=CreateInvariant[Group,RepScalar,InputInv][[1]]//Simplify//FullSimplify;

InputInv={{3,2},{True,False}};(*\[Phi]3\[Phi]2^+*)
\[Phi]23=CreateInvariant[Group,RepScalar,InputInv][[1]]//Simplify//FullSimplify;


(* Define some shorthands for complex parameters. DRalgo performs better if real/imag parts are used separately. *)
\[Mu]12sq = \[Mu]12sqRe + I*\[Mu]12sqIm;
\[Mu]12sqConj = Conjugate[\[Mu]12sq]//ComplexExpand;

\[Lambda]1 = \[Lambda]1Re + I*\[Lambda]1Im;
\[Lambda]1Conj = Conjugate[\[Lambda]1]//ComplexExpand;
\[Lambda]2 = \[Lambda]2Re + I*\[Lambda]2Im;
\[Lambda]2Conj = Conjugate[\[Lambda]2]//ComplexExpand;
\[Lambda]3 = \[Lambda]3Re + I*\[Lambda]3Im;
\[Lambda]3Conj = Conjugate[\[Lambda]3]//ComplexExpand;


(* Quadratic terms. Careful with complex conjugates *)
VMass=-\[Mu]1sq*\[Phi]11 - \[Mu]2sq*\[Phi]22 - \[Mu]3sq*\[Phi]33 - \[Mu]12sq*\[Phi]12 - \[Mu]12sqConj*\[Phi]21 // Simplify // Expand; (* simplify to get rid of imag units *)


\[Mu]ij=GradMass[VMass]//Simplify//SparseArray;


(** Def. quartic terms. Careful with complex conjugates **) 
QuarticTerm1 = \[Lambda]11*\[Phi]11^2 + \[Lambda]22*\[Phi]22^2 + \[Lambda]33*\[Phi]33^2;
QuarticTerm2 = \[Lambda]12*\[Phi]11*\[Phi]22 + \[Lambda]23*\[Phi]22*\[Phi]33 + \[Lambda]31*\[Phi]33*\[Phi]11;
QuarticTerm3 = \[Lambda]12p*\[Phi]12*\[Phi]21 + \[Lambda]23p*\[Phi]23*\[Phi]32 + \[Lambda]31p*\[Phi]31*\[Phi]13;
QuarticTerm4 = \[Lambda]1*\[Phi]12^2 + \[Lambda]2*\[Phi]23^2 + \[Lambda]3*\[Phi]31^2;
(* Hermitian conjugate of QuarticTerm4. Just adding it as ConjugateTranspose[...] didn't work, DRalgo just seemed to get stuck. *)
QuarticTerm5 = \[Lambda]1Conj*\[Phi]21^2 + \[Lambda]2Conj*\[Phi]32^2 + \[Lambda]3Conj*\[Phi]13^2;
VQuartic=QuarticTerm1 + QuarticTerm2 + QuarticTerm3 + QuarticTerm4 + QuarticTerm5 // Simplify // Expand; (* simplify to get rid of imag units *)
\[CapitalLambda]4=GradQuartic[VQuartic];


InputInv={{1,1,2},{False,False,True}}; 
YukawaDoublet1=CreateInvariantYukawa[Group,RepScalar,RepFermion3Gen,InputInv][[1]]//Simplify;


InputInv={{2,1,2},{False,False,True}}; 
YukawaDoublet2=CreateInvariantYukawa[Group,RepScalar,RepFermion3Gen,InputInv][[1]]//Simplify;


InputInv={{3,1,2},{False,False,True}}; 
YukawaDoublet3=CreateInvariantYukawa[Group,RepScalar,RepFermion3Gen,InputInv][[1]]//Simplify;


(*Ysff=-GradYukawa[yt1*YukawaDoublet1+yt2*YukawaDoublet2+yt3*YukawaDoublet3];*)
Ysff=-GradYukawa[yt3*YukawaDoublet3];
YsffC=SparseArray[Simplify[Conjugate[Ysff]//Normal,Assumptions->{yt3>0}]];


(* ::Section:: *)
(*Dimensional Reduction*)


(* ::Text:: *)
(*Parametric accuracy goal of the EFT matchings need to be specified already in ImportModelDRalgo[] (Mode option). I will first do a LO matching and export that, then import the model again and repeat with order g^4 matching.*)
(*Mode -> 0 : Match couplings at tree level and masses at 1-loop (full g^2)*)
(*Mode -> 1 : Match everything at 1-loop (partial g^4)*)
(*Mode -> 2 : Match couplings at 1-loop and masses at 2-loop (full g^4) *)
(**)
(*However Mode->0 does not really work ATM,  it doesn't give couplings etc...*)


(* ::Subsection::Closed:: *)
(*Helper function for combining LO and NLO substitution rules*)


(**  Here the lists are assumed to have elements of form symbol -> expr. 
This function joins substitution rules from list1 and list2 so that the final subst rule is symbol -> expr1 + expr2. **)
CombineSubstRules[list1_, list2_] := Block[{combinedList,groupedRules},

	(** Magic code written by ChatGPT. But it works **)
	
	combinedList = Join[list1, list2];
	(* Group the rules by their left-hand sides *)
	groupedRules = GroupBy[combinedList, #[[1]] &];

	(* Sum up the right-hand sides for each group *)
	resultList = Rule @@@ KeyValueMap[{#1, Total[#2[[All, 2]]]} &, groupedRules];
	Return[resultList];
];


(* ::Subsection:: *)
(*NLO matching, by which I mean Mode -> 2*)


(** Normalization4D flag = preserve 4D units so that the EFT path integral weight is e^{-S/T} **)
(** TODO well currently the Normalization4D flag does not work... I've made an issue on Github **)
(** AutoRG->True means that 3D running is built in to the matching. This is bad for automatization since 
the 3D masses become be functions of other 3D parameters. To dodge this we match with AutoRG->False
and do the RG running manually in an additional stage. **)
 
ImportModelDRalgo[Group,gvvv,gvff,gvss,\[CapitalLambda]1,\[CapitalLambda]3,\[CapitalLambda]4,\[Mu]ij,\[Mu]IJ,\[Mu]IJC,Ysff,YsffC,Verbose->False, Mode->2, Normalization4D->False, AutoRG->False];
PerformDRhard[];


(*Also generated by claude ai, V3.5*)
BetaFunctions4DUnsquared[] = BetaFunctions4D[] /. {(x_^2 -> y_) :> (x -> y/(2*x))};
ExportUTF8[hardToSoftDirectory<>"/BetaFunctions4D.txt", BetaFunctions4DUnsquared[]];


couplingsSoft = PrintCouplings[];
temporalScalarCouplings = PrintTemporalScalarCouplings[];
debyeMasses = PrintDebyeMass["LO"]; (** For Debyes we only take LO result, NLO not needed since we integrate these out anyway **)
scalarMasses = CombineSubstRules[PrintScalarMass["LO"], PrintScalarMass["NLO"]];
allSoftScaleParams = Join[couplingsSoft, temporalScalarCouplings, debyeMasses, scalarMasses];


(*DRalgo gives temporal couplings with [] which is a function call which makes things awkward so remove the []*)
\[Lambda]VL[i_]:=ToExpression["\[Lambda]VL"<>ToString[i]];
\[Lambda]VLL[i_]:=ToExpression["\[Lambda]VLL"<>ToString[i]];


(*Gauge couplings given as g_i^2 even though g_i is what is needed, so take sqrt. Fine to do so long as g_i >0*)
sqrtSubRules[ruleList_]:=Module[{newRules},
  newRules = ruleList /. (lhs_ -> expr_) /; MatchQ[lhs, _^2] :> (PowerExpand[Sqrt[lhs]] -> Sqrt[expr]);
  Return[newRules];
];


(*We want to do in place updating of parameters in the python code i.e. \[Lambda]14D gets updated to \[Lambda]13D which gets updated to \[Lambda]13DUS,
it's easier to do this if we remove the suffices so its the same variable name throughout*)
allSoftScaleParamsSqrtSuffixFree = RemoveSuffixes[sqrtSubRules[allSoftScaleParams], {"3d"}];
(*Added during the dict to array moving and changing RGScale to T etc*)
allSoftScaleParamsSqrtSuffixFree = Join[allSoftScaleParamsSqrtSuffixFree, {T->T,RGScale->RGScale}];
ExportUTF8[hardToSoftDirectory<>"/softScaleParams_NLO.txt", allSoftScaleParamsSqrtSuffixFree]


(* 3D RG equations can be solved exactly, so do that here. We will export subst rules analogous to the matching relations:
	msq -> msq + \[Beta][msq] Log[\[Mu]3/\[Mu]] where RHS msq is the 3D mass at scale \[Mu] and LHS msq is the mass at scale \[Mu]3 *)
	
SolveRunning3D[betaFunctions_] := Block[{exprList},
	(* Extracting lhs and beta for each list element *)
	exprList = {#[[1]], #[[2]]} & /@ betaFunctions;

	(* Make new list with RGE solution on RHS *)
	newRulesList = (#1 -> #1 + #2*Log[T/RGScale]) & @@@ exprList;
	Return[newRulesList];
];

running3DSoft = RemoveSuffixes[SolveRunning3D[BetaFunctions3DS[]],{"3d"}];
running3DSoft= Join[running3DSoft, {RGScale->T}];
ExportUTF8[hardToSoftDirectory<>"/softScaleRGE.txt", running3DSoft]


(* ::Subsection:: *)
(*Soft -> Ultrasoft matching*)


PerformDRsoft[{}];
(** This now works properly as of DRalgo 2023/11/24 update **)
couplingsUS = PrintCouplingsUS[];
scalarMassesUS = CombineSubstRules[PrintScalarMassUS["LO"], PrintScalarMassUS["NLO"]];

allUltrasoftScaleParams = Join[couplingsUS, scalarMassesUS] /. \[Mu]3->RGScale;


allUltrasoftScaleParamsSqrt = RemoveSuffixes[sqrtSubRules[allUltrasoftScaleParams], {"US", "3d"}];(*Some reduant sqrt operations here? e.g. g13dUS*)
allUltrasoftScaleParamsSqrt= Join[allUltrasoftScaleParamsSqrt, {mu3US -> T}];


ExportUTF8[softToUltrasoftDirectory<>"/ultrasoftScaleParams_NLO.txt", allUltrasoftScaleParamsSqrt]


running3DUS = RemoveSuffixes[SolveRunning3D[BetaFunctions3DUS[]],{"US", "3d"}];
ExportUTF8[softToUltrasoftDirectory<>"/ultrasoftScaleRGE.txt", running3DUS]


(* ::Section:: *)
(*Effective potential*)


(* ::Text:: *)
(*We need to give DRalgo two things: *)
(*1) Rotation matrices for scalar and gauge fields that bring the original field vectors to mass eigenstate basis*)
(*2) Diagonal mass-squared matrices for both scalars and gauges. The ordering of masses needs to match the order to which the rotation matrix brings the fields.*)
(**)
(*We will export a lot of symbolical data for diagonalization, mass eigenvalues, shorthand symbols in rotation matrices etc. These can then be evaluated numerically in an external program. The order of evaluations should be:*)
(*1. Obtain action parameters*)
(*2. Obtain background field values*)
(*3. Solve diagonalization equations for scalars and vectors -> get angles or sines (cosines) of the angles.*)
(*For scalars, use any linear algebra library to diagonalize the mass matrix and get the diagonalizing rotation.*)
(*4. Evaluate masses and rotation matrix elements in the form in which they enter the Veff expression. *)
(*5. Plug all of the above in to the Veff expressions*)
(**)
(*In principle there could be additional shorthands computed between steps 2 and 3 if the diagonalization conditions themselves depend on some shorthand symbols, but we're not including this currently.*)


(* ::Subsection:: *)
(*Specify background fields and init DRalgo stuff*)


UseUltraSoftTheory[];
DefineNewTensorsUS[\[Mu]ij,\[CapitalLambda]4,\[CapitalLambda]3,gvss,gvvv]; 
PrintScalarRepPositions[](** This is supposed to tell which index is which field, but it's cryptic... **)

(** DRalgo ordering: real parts go before imag parts, and this is repeated 3 times (because we have 3 complex doublets). 
So the "usual" place for BG field is second index in each doublet**)

backgroundFieldsFull = {(*\[Phi]1*)0, v1, 0, 0,(*\[Phi]2*)0, v2, 0, 0, (*\[Phi]3*)0, v3, 0, 0}//SparseArray; 
DefineVEVS[backgroundFieldsFull];


(* ::Subsection:: *)
(*Diagonalizing scalar mass matrix*)


(* ::Text:: *)
(*Finding the diagonalizing matrix analytically is likely impossible, so we brute force this by giving DRalgo a symbolic 12x12 matrix with unknown symbols and compute the Veff in terms of those symbols. For masses we give an unknown diagonal matrix. These unknown are field-dependent so we must solve them numerically every time the potential is evaluated. *)
(**)
(*Note that using unknown symbols in the rotation matrix means that DRalgo will compute the effective potential in what is effectively a non-diagonal field basis, ie. there is quadratic mixing. But all the mixing effects vanish when numerical values are fixed by diagonalization conditions later on. (And I believe DRalgo ignores quadratic vertices anyway, but have not confirmed this). *)
(**)
(*Now, there are some optimizations that we can do. For example with the 3-field configuration defined above, the mass matrix can be brought into block-diagonal form by permuting the fields. This reduces the problem to diagonalization of two 6x6 matrices which is faster. We use this approach here; the required 12x12 rotation then has zeros in many places so DRalgo has easier time working with it.*)


scalarMM = PrintTensorsVEV[1]//Normal//Simplify; (* Scalar mass matrix, simplify to get rid of possible imaginary units *)


(* ::Subsubsection::Closed:: *)
(*Helpers for indexed symbols*)


(** For table building etc it's convenient to use indices with []. 
But for exporting let's get rid of the [] since those are actually function calls in Mathematica.
Instead, we will just use a symbol with numbers attached to denote the indices, but to guarantee each
combination of indices produces an unique symbol we have to pad the indices with zeros.
**)

(* Turns a number into string and pads it with leading zeros *)
toPaddedString[idx_, numZeros_Integer] := Block[{},
	If[numZeros < 1, ToString[idx], 
		StringJoin@ConstantArray["0", numZeros]<>ToString[idx]
	]
];

toIndexedSymbol[symbol_, idx_, minDigits_Integer: 1] := Block[{paddedIdx},
	paddedIdx = toPaddedString[idx, minDigits-1 - Floor[Log10[idx]]];
	
	ToExpression[ ToString[symbol]<>paddedIdx ]
];

toIndexedSymbol2[symbol_, idx1_, idx2_, minDigits_Integer: 1] := Block[{paddedIdx1, paddedIdx2},
	paddedIdx1 = toPaddedString[idx1, minDigits-1 - Floor[Log10[idx1]]];
	paddedIdx2 = toPaddedString[idx2, minDigits-1 - Floor[Log10[idx2]]];
	
	ToExpression[ ToString[symbol]<>paddedIdx1<>paddedIdx2 ]
];

(** Replace non-numeric matrix elements by simple symbols. eg. long expression at matrix[[i,j]] -> elementSymbolX
where X is a number starting from 0. Each element gets a unique symbol. Returns the symbolic matrix and list of shorthands. **)
toSymbolicMatrix[matrix_, elementSymbol_, bIsSymmetric_: False] := Block[
{i, j, count, symbolicMatrix, shape, rows, columns, shorthandDefinitions, tempMatrix},
	
	count = 0;
	shape = Dimensions[matrix];
	{rows, columns} = shape;
	
	(** don't replace numerical elements (esp. 0 or 1) **) 
	IsTrivialQ[el_] := Return[ NumericQ[el] ];
	
	(** Helper. This is messy but am lazy. SetAttributes is used in order to modify the shorthandList argument **)
	SetAttributes[AppendSymbolicShorthand, HoldAll];
	AppendSymbolicShorthand[el_, shorthandBase_, shorthandList_] := Block[{substRule, shorthand},
		If[ !IsTrivialQ[el],
			shorthand = ToExpression[ToString[shorthandBase]<>ToString[count]];
			substRule = shorthand -> el;
			AppendTo[shorthandList, substRule];
			count++;
			Return[shorthand];
			,
			(* else *)
			Return[el];
		];
	];
	
	shorthandDefinitions = {};
		
	If[!bIsSymmetric,
		symbolicMatrix = Table[ AppendSymbolicShorthand[ matrix[[i,j]], elementSymbol, shorthandDefinitions ], {i,1,rows},{j,1,columns}];
	,
	(* Symmetric matrix: fill in symbols in the upper right half only *)
		tempMatrix = Table[
			AppendSymbolicShorthand[ matrix[[i,j]], elementSymbol, shorthandDefinitions ],
		{i,1,rows},{j,1,i}];
		
		symbolicMatrix = Table[
			If[j<=i, tempMatrix[[i,j]], tempMatrix[[j,i]]], {i,1,rows}, {j,1,columns}
		];
	];
	
	Return[{symbolicMatrix, shorthandDefinitions}];
];


(* ::Subsubsection:: *)
(*Permute scalars to make mass matrix block-diagonal *)


(* Permutation matrix swaps the following rows and colums: 2<->11, 4<->9,6<->7  to get a block diagonal matrix. 
These are the minimal swaps to get a block diagonal matrix, and conviently leave the permutation symmetric.  
Once permuted the order of the mass matrix will be: 
Re\[Phi]1, Im\[Phi]3, Im\[Phi]1, Re\[Phi]3, Re\[Phi]2, Im\[Phi]2 (charged dof)
Re\[Phi]2, Im\[Phi]2, Im\[Phi]1, Re\[Phi]3, Re\[Phi]1, Im\[Phi]3  (neutral dof)*)
scalarPermutationMatrix = {
{1,0,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,1,0},
{0,0,1,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,1,0,0,0},
{0,0,0,0,1,0,0,0,0,0,0,0},
{0,0,0,0,0,0,1,0,0,0,0,0},
{0,0,0,0,0,1,0,0,0,0,0,0},
{0,0,0,0,0,0,0,1,0,0,0,0},
{0,0,0,1,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,1,0,0},
{0,1,0,0,0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0,0,0,0,1}};
If[!OrthogonalMatrixQ[scalarPermutationMatrix], Print["Error, permutation matrix is not orthogonal"]];
ExportUTF8[effectivePotentialDirectory<>"/scalarPermutationMatrix2.txt", StringReplace[ToString[scalarPermutationMatrix],{"{"->"[","}"->"]"}]];


(*Our casescalarPermutationMatrix is symmetric but taking transpose anyway for consistency/future proofing*)
blockDiagonalMM = Transpose[scalarPermutationMatrix] . scalarMM . scalarPermutationMatrix;
Print["Block diagonal mass matrix:"];
blockDiagonalMM//MatrixForm

(*Extract permutation matrix and do consistency check*)
upperLeftMM = Take[blockDiagonalMM,{1,6},{1,6}];
bottomRightMM = Take[blockDiagonalMM,{7,12},{7,12}];

If[!SymmetricMatrixQ[upperLeftMM] || !SymmetricMatrixQ[bottomRightMM], Print["Error, block not symmetric!"]];


(* ::Subsubsection:: *)
(*Export scalar mass matrix*)


(* Simplify both blocks by introducing additional symbols, then extract them separately *)
{upperLeftMMSymbolic, upperLeftMMDefinitions} = toSymbolicMatrix[upperLeftMM, "MMUL", True]//Simplify;
{bottomRightMMSymbolic, bottomRightMMDefinitions} = toSymbolicMatrix[bottomRightMM, "MMBR", True]//Simplify;

(* Export expressions separately because we have the code to parse that *)
ExportUTF8[effectivePotentialDirectory<>"/scalarMassMatrix_upperLeft.txt", upperLeftMMSymbolic];
ExportUTF8[effectivePotentialDirectory<>"/scalarMassMatrix_upperLeft_definitions.txt", upperLeftMMDefinitions];


ExportUTF8[effectivePotentialDirectory<>"/scalarMassMatrix_bottomRight.txt", bottomRightMMSymbolic];
ExportUTF8[effectivePotentialDirectory<>"/scalarMassMatrix_bottomRight_definitions.txt", bottomRightMMDefinitions];


(* ::Subsubsection:: *)
(*Construct scalar rotation matrix *)


blockSize = 6;
(** Diagonalizing rotation, this will be SO(N) with N=12. But we know a permutation transformation to reduce it to two SO(6) matrices,
so we first construct the two SO(6) and apply the inverse permutation. 
There's no easy way of generating a symbolic orthogonal matrix so just use a generic 6x6
This was done before DRalgo's fast rotate mode -TODO investigate fast rotate **)
rotUpperLeft = Table[ toIndexedSymbol2[ "RUL", i, j, Total[DigitCount[blockSize]] ], {i, 1, blockSize}, {j, 1, blockSize}];
rotBottomRight = Table[ toIndexedSymbol2[ "RBR", i, j, Total[DigitCount[blockSize]] ], {i, 1, blockSize}, {j, 1, blockSize}];

DSRotBlock = ArrayFlatten[{
{rotUpperLeft, 0},
{0, rotBottomRight}
}];
(* V = \[Phi]^T.M.\[Phi] 
	 = \[Phi]^T.P.P^T.M.P.P^T.\[Phi] = \[Phi]^T.P.B.P^T.\[Phi], make the mass matrix block diagonal, with some permutation matrix P: P^T.M.P = B
	 = \[Phi]^T.P.S.S^T.B.S.S^T.P^T.\[Phi] = \[Phi]^T.P.S.B.S^T.P^T.\[Phi], make the block diagonal mass matrix diagonal, with some similarity transform S: S^T.B.P = D'
Note P = scalarPermutationMatrix, S = DSRotBlock
Since we give DRalgo an arbitrary diagonal matrix and rotation matrix we have
V = \[Phi]^T.M.\[Phi]
  = \[Phi]^T.R.R^T.M.R.R^T.\[Phi] = \[Phi]^T.R.D.R^T.\[Phi]
We impose D = D' so R = P.S
We compute D' and S in the python code numerically
*)

DSRot = scalarPermutationMatrix . DSRotBlock;
Print["Scalar diagonalizing rotation:"];
DSRot//MatrixForm

ExportUTF8[effectivePotentialDirectory<>"/scalarRotationMatrix.txt", DSRot];

(** Diagonal mass matrix, unknown symbols **)
ScalarMassDiag = DiagonalMatrix[ Table[toIndexedSymbol["MSsq", i, Total[DigitCount[12]]], {i, 1, 12}] ];


(* ::Subsection:: *)
(*Gauge field diagonalization*)


(* ::Text:: *)
(*This is mostly hardcoded these for now. The diagonalization is identical to the Standard Model case*)


VectorMassMatrix = PrintTensorsVEV[2]//Normal;
vectorN = 12; (* SU3 x SU2 x U1 *)

(** Take the only nontrivial 2x2 submatrix and diagonalize that **) 
VectorMassMatrixNontrivial = VectorMassMatrix[[11;;12,11;;12]];
{VectorEigenvalues, VectorEigenvectors} = Eigensystem[VectorMassMatrixNontrivial];
VectorEigenvectors = FullSimplify[ Normalize /@ VectorEigenvectors, Assumptions -> {g3>0, g2>0, g1>0}];

(** Diagonalizing rotation: **)
DVRot = ArrayFlatten[{
	{IdentityMatrix[10], 0, 0},
	{0, 0, VectorEigenvectors}
}];

(* Eigenvalues in correct order. Just pick diagonals from the original mass matrix, then replace the ones we had to diagonalize manually  *)
VectorMassDiag = Table[ If[i==j, VectorMassMatrix[[i,i]], 0], {i, 1, 12}, {j, 1, 12}] //Simplify;
VectorMassDiag[[11,11]] = VectorEigenvalues[[1]];
VectorMassDiag[[12,12]] = VectorEigenvalues[[2]];

Print["Diagonalized vector mass matrix:"];
VectorMassDiag // MatrixForm

(** Simplify with easier symbols **)
gaugeRotationSubst = {g1/Sqrt[g1^2+g2^2] -> stW, g2/Sqrt[g1^2+g2^2] -> ctW};
DVRot = DVRot /. gaugeRotationSubst;

vectorShorthands = {stW-> g1/Sqrt[g1^2+g2^2], ctW-> g2/Sqrt[g1^2+g2^2]};

(** Vector masses mVsq[i]. **)
{VectorMassDiagSimple, VectorMassExpressions} = toSymbolicMatrix[VectorMassDiag, mVsq];

ExportUTF8[effectivePotentialDirectory<>"/vectorMasses.txt", VectorMassExpressions];
ExportUTF8[effectivePotentialDirectory<>"/vectorShorthands.txt", vectorShorthands];


(* ::Subsection:: *)
(*Calculating the effective potential*)


(** NB! RotateTensorsCustomMass[] is very very slow, this can run for hours!
It's because our scalar rotation matrix is so large. **)
AbsoluteTiming[
	(** Tell DRalgo to rotate the fields to mass diagonal basis **)
	RotateTensorsCustomMass[DSRot,DVRot,ScalarMassDiag,VectorMassDiagSimple];
	CalculatePotentialUS[]
]


VeffLO = PrintEffectivePotential["LO"]//Simplify; (* Simplify to get rid of possible imaginary units *)
VeffNLO = PrintEffectivePotential["NLO"]//Simplify; (* Simplify to factor 1/pi division for tiny speed up *)
VeffNNLO = PrintEffectivePotential["NNLO"]; (* NOT simplified as seems to change numerical result for unknown reasons *)
VeffLO = LO -> VeffLO;
VeffNLO = NLO -> VeffNLO;
VeffNNLO = NNLO -> VeffNNLO;
ExportUTF8[effectivePotentialDirectory<>"/Veff_LO.txt", VeffLO];
ExportUTF8[effectivePotentialDirectory<>"/Veff_NLO.txt", VeffNLO];
ExportUTF8[effectivePotentialDirectory<>"/Veff_NNLO.txt", VeffNNLO];


extractSymbols[expr_] := Union[Cases[expr, s_Symbol /; 
    (* Exclude built-in symbols *)
    !MemberQ[Attributes[s], Protected] && 
    (* Exclude temporary pattern variables *)
    !StringMatchQ[SymbolName[s], "$" ~~ ___] &&
    (* Exclude context-specific symbols *)
    Context[s] =!= "System`", 
    Infinity]]


(* Apply the function to each element in the list and flatten results *)
fourPointSymbols = DeleteDuplicates @ Flatten[splitExpr /@ DeleteDuplicates @ Flatten[splitExpr /@ \[CapitalLambda]4]];
(** I don't know when this will ever be needed but incase it is ever needed\.12 **)
threePointSymbols = DeleteDuplicates @ Flatten[splitExpr /@ DeleteDuplicates @ Flatten[splitExpr /@ \[CapitalLambda]3]] ;
twoPointSymbols = DeleteDuplicates @ Flatten[splitExpr /@ DeleteDuplicates @ Flatten[splitExpr /@ \[Mu]ij]];
yukawaSymbols = DeleteDuplicates @ Flatten[splitExpr /@ DeleteDuplicates @ Flatten[splitExpr /@ Ysff]];


ExportUTF8[variables<>"/LagranianSymbols.json", {"fourPointSymbols"-> symbolsToStrings[fourPointSymbols],
												"threePointSymbols"-> symbolsToStrings[threePointSymbols],
												"twoPointSymbols"-> symbolsToStrings[twoPointSymbols],
												"gaugeSymbols"-> symbolsToStrings[GaugeCouplings],
												"yukawaSymbols" -> symbolsToStrings[yukawaSymbols],
												"fieldSymbols" -> symbolsToStrings[DeleteDuplicates @ Flatten[splitExpr /@ backgroundFieldsFull]]				   															   															   															   															   
												} ]
												


(*The scalar mass matrices are a bit hacky since they don't have a direct out and the block diagonal nature means they shouldn't share the same out*)
ExportUTF8[variables<>"/EquationSymbols.json", {"hardScaleRGE"->{"Out" -> symbolsToStrings[Part[GetSubstitutionSymbols[BetaFunctions4DUnsquared[]],1]],
															   "In" -> symbolsToStrings[Part[GetSubstitutionSymbols[BetaFunctions4DUnsquared[]],2]]},
												"softScaleParams"->{"Out" -> symbolsToStrings[Part[GetSubstitutionSymbols[allSoftScaleParamsSqrtSuffixFree],1]],
																   "In" -> symbolsToStrings[Part[GetSubstitutionSymbols[allSoftScaleParamsSqrtSuffixFree],2]]},
												"softScaleRGE"->{"Out" -> symbolsToStrings[Part[GetSubstitutionSymbols[running3DSoft],1]],
																"In" -> symbolsToStrings[Part[GetSubstitutionSymbols[running3DSoft],2]]},	
												"ultraSoftScaleParams"->{"Out" -> symbolsToStrings[Part[GetSubstitutionSymbols[allUltrasoftScaleParamsSqrt],1]],
																        "In" -> symbolsToStrings[Part[GetSubstitutionSymbols[allUltrasoftScaleParamsSqrt],2]]},
												"ultraSoftScaleRGE"->{"Out" -> symbolsToStrings[Part[GetSubstitutionSymbols[runningUS],1]],
																     "In" -> symbolsToStrings[Part[GetSubstitutionSymbols[runningUS],2]]},	
												"upperLeftMMDefinitions"->{"Out" -> symbolsToStrings[DeleteDuplicates @ Flatten[splitExpr /@ ScalarMassDiag]],
																          "In" -> symbolsToStrings[Part[GetSubstitutionSymbols[upperLeftMMDefinitions],2]]},
												"bottomRightMMDefinitions"->{"Out" -> symbolsToStrings[DeleteDuplicates @ Flatten[splitExpr /@ ScalarMassDiag]],
																            "In" -> symbolsToStrings[Part[GetSubstitutionSymbols[bottomRightMMDefinitions],2]]},
												"vectorMasses"->{"Out" -> symbolsToStrings[DeleteDuplicates @ Flatten[splitExpr /@ VectorMassDiagSimple]],
																"In" -> symbolsToStrings[Part[GetSubstitutionSymbols[VectorMassExpressions],2]]},
												"rotationSymbols"->symbolsToStrings[DeleteDuplicates @ Flatten[splitExpr /@ DSRot]],
												"LO"->{"Out"->symbolsToStrings[Part[GetSubstitutionSymbols[VeffLO],1]],
													   "In"->symbolsToStrings[Part[GetSubstitutionSymbols[VeffLO],2]]},
												"NLO"->{"Out"->symbolsToStrings[Part[GetSubstitutionSymbols[VeffNLO],1]],
													   "In"->symbolsToStrings[Part[GetSubstitutionSymbols[VeffNLO],2]]},
												"NNLO"->{"Out"->symbolsToStrings[Part[GetSubstitutionSymbols[VeffNNLO],1]],
													   "In"->symbolsToStrings[Part[GetSubstitutionSymbols[VeffNNLO],2]]}				   															   															   															   															   
												} ]
												


(*Claude 3.5 again*)
(*Loading in the json again to extract all symbols from as less effort than doing again in mathematica or down the line in python*)
ExtractSymbols[data_]:=Module[{results={}},Which[(*If it's a string,try to convert to symbol*)StringQ[data],AppendTo[results,Symbol[data]],(*If it's a list,process each element*)ListQ[data],results=Flatten[Map[ExtractSymbols,data]],(*If it's an association,process only values*)AssociationQ[data],results=Flatten[Map[ExtractSymbols,Values[data]]],(*Handle Rule objects*)MatchQ[data,_Rule],results=ExtractSymbols[data[[2]]],(*Only process the right-hand side*)(*Handle lists of rules*)MatchQ[data,{___Rule}],results=Flatten[Map[ExtractSymbols[#[[2]]]&,data]],(*Process right-hand sides*)True,Print["Unhandled type: ",Head[data]]];
DeleteDuplicates[results]]


ExportUTF8[variables<>"/allSymbols.json",symbolsToStrings[ExtractSymbols[Import[variables<>"/EquationSymbols.json"]]]]
